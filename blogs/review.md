1. MVC control 继承那个基类

   Microsoft.AspNetCore.Mvc.Controller
   System.Web.Mvc.Controller
   System.Web.Http.ApiController

   [mvc接口、webapi、webservice 对比](https://www.cnblogs.com/highest/p/8269183.html)


2. ioc  aop
ioc 控制反转 高层不调用底层 用到的插件有unity  spring
aop 面向切面 不影响主要业务情况添加功能  用到的地方如：错误日志   做某个业务后可以做其他事，如发邮件  发信息

3. 接口、抽象类
抽象类表示的是，这个对象是什么。接口表示的是，这个对象能做什么。
接口可以多继承 抽象类不能

[C#.NET里面抽象类和接口有什么区别](https://www.cnblogs.com/binyao/p/4891306.html)
一、抽象类
    (1) 抽象方法只作声明，而不包含实现，可以看成是没有实现体的虚方法
    (2) 抽象类不能被实例化
    (3) 抽象类可以但不是必须有抽象属性和抽象方法，但是一旦有了抽象方法，就一定要把这个类声明为抽象类
    (4) 具体派生类必须覆盖基类的抽象方法
    (5) 抽象派生类可以覆盖基类的抽象方法，也可以不覆盖。如果不覆盖，则其具体派生类必须覆盖它们。
二、接 口
    (1) 接口不能被实例化
    (2) 接口只能包含方法声明
    (3) 接口的成员包括方法、属性、索引器、事件
    (4) 接口中不能包含常量、字段(域)、构造函数、析构函数、静态成员。
    (5) 接口中的所有成员默认为public，因此接口中不能有private修饰符
    (6) 派生类必须实现接口的所有成员
    (7) 一个类可以直接实现多个接口，接口之间用逗号隔开
    (8) 一个接口可以有多个父接口，实现该接口的类必须实现所有父接口中的所有成员
三、抽象类和接口
    相同点：
    (1) 都可以被继承
    (2) 都不能被实例化
    (3) 都可以包含方法声明
    (4) 派生类必须实现未实现的方法
    区 别：
    (1) 抽象基类可以定义字段、属性、方法实现。接口只能定义属性、索引器、事件、和方法声明，不能包含字段。
    (2) 抽象类是一个不完整的类，需要进一步细化，而接口是一个行为规范。微软的自定义接口总是后带able字段，证明其是表述一类“我能做。。。”
    (3) 接口可以被多重实现，抽象类只能被单一继承
    (4) 抽象类更多的是定义在一系列紧密相关的类间，而接口大多数是关系疏松但都实现某一功能的类中
    (5) 抽象类是从一系列相关对象中抽象出来的概念， 因此反映的是事物的内部共性；接口是为了满足外部调用而定义的一个功能约定， 因此反映的是事物的外部特性
    (6) 接口基本上不具备继承的任何具体特点,它仅仅承诺了能够调用的方法   
    (7) 接口可以用于支持回调,而继承并不具备这个特点
    (8) 抽象类实现的具体方法默认为虚的，但实现接口的类中的接口方法却默认为非虚的，当然您也可以声明为虚的 
    (9) 如果抽象类实现接口，则可以把接口中方法映射到抽象类中作为抽象方法而不必实现，而在抽象类的子类中实现接口中方法

4 gc
 垃圾回收机制..一段时间会回收 不使用变量   首先继承IDisposable这个类  可以手动回收垃圾  gc中die的作用   GC.Collect()

[浅谈C#垃圾回收](https://www.cnblogs.com/cuiyiming/archive/2013/03/26/2981931.html)

理解C#垃圾回收机制我们首先说一下CLR（公共语言运行时,Common Language Runtime）它和Java虚拟机一样是一个运行时环境，核心功能包括：内存管理、程序集加载、安全性、异步处理和线程同步。

CTS（Common Type System）通用类型系统，它把.Net中的类型分为2大类，引用类型与值类型。.Net中所有类型都间接或直接派生至System.Object类型。所有的值类型都是System.ValueType的子类，而System.ValueType本身却是引用类型。

托管资源：
　　由CLR管理的存在于托管堆上的称为托管资源，注意这里有2个关键点，第一是由CLR管理，第二存在于托管堆上。托管资源的回收工作是不需要人工干预的，CLR会在合适的时候调用GC(垃圾回收器)进行回收。

非托管资源：
　　非托管资源是不由CLR管理，例如：Image Socket, StreamWriter, Timer, Tooltip, 文件句柄, GDI资源, 数据库连接等等资源（这里仅仅列举出几个常用的）。这些资源GC是不会自动回收的，需要手动释放。

通过上面的讲述总结一下，第一，GC(垃圾回收器)只回收托管资源，不回收非托管资源。第二，GC回收是要在合适的时候（CLR觉得应该进行回收的时候）才进行回收。那么非托管如何进行回收呢？下面就让我一一道来。
在.Net中释放非托管资源主要有2种方式，Dispose，Finalize

5.数据库索引
聚集索引 存在物理磁盘   非聚集  在 表

非聚集索引可以多个， 聚集只有一个
用了索引后为null会不会影响搜索查询  聚集
会影响

 [SQL Server的聚集索引和非聚集索引](https://www.cnblogs.com/tuyile006/archive/2009/08/28/1555615.html)

 我们把正文内容本身就是按照一定规则排列的目录称为“聚集索引”。
 如：汉语字典的正文，本身是以英文字母“a”开头并以“z”结尾的排序的

 我们把这种目录纯粹是目录，正文纯粹是正文的排序方式称为“非聚集索引”。
 如：按部首查字，需要两个过程，先找到部首目录的结果再翻到所需要的页码。

下面的表总结了何时使用聚集索引或非聚集索引：


动作描述                           使用聚集索引         使用非聚集索引

外键列                                 应                    应
主键列                                 应                    应
列经常被分组排序(order by)              应                    应
返回某范围内的数据                      应                    不应
小数目的不同值                          应                    不应
大数目的不同值                          不应                  应
频繁更新的列                            不应                  应
频繁修改索引列                          不应                  应
一个或极少不同值                        不应                  不应

事实上，我们可以通过前面聚集索引和非聚集索引的定义的例子来理解上表。如：返回某范围内的数据一项。比如您的某个表有一个时间列，恰好您把 聚合索引建立在了该列，这时您查询2004年1月1日至2004年10月1日之间的全部数据时，这个速度就将是很快的，因为您的这本字典正文是按日期进行 排序的，聚类索引只需要找到要检索的所有数据中的开头和结尾数据即可;而不像非聚集索引，必须先查到目录中查到每一项数据对应的页码，然后再根据页码查到 具体内容。

[SQL Server 调优系列](https://www.cnblogs.com/MuNet/p/9372826.html)


6 lock
线程 锁, 解决线程并发 但是影响性能 尽量要用在缩小 锁范围   最好解决并发问题的方法是数据分离 没办法再用锁


7单例 实现方式

 1.饿汉式 懒汉式 一个 实例时候 自动实例 一种写在方法 被动创建实例
如果你吹单例，他会问怎样实现的 你就说有会三种
说二种就好
实示方式如下
第一种 要加锁的
 public class Singleton
    {
        private static Singleton singleton = null;
        private static object Sinleton_Lock = new object();
        private Singleton()
        {
           
            Console.WriteLine($"{this.GetType().Name}被次构造一次");

        }
        public static Singleton CreateInstance()
        {
            if (singleton == null)
            {
                lock (Sinleton_Lock)
                {
                    Thread.Sleep(1000);
                    Console.WriteLine("等待一秒钟");
                    if (singleton == null)
                    {
                        singleton = new Singleton();
                    }
                }
            }
           
            return singleton;
        }

第二种
 public class SingletonSecond
    {
        private static SingletonSecond _SingletonSecond = null;
        /// <summary>
        /// 单例类：一个构造对象很耗时耗资源类型
        /// </summary>
        private SingletonSecond()
        {
          
            Console.WriteLine($"{this.GetType().Name}被次构造一次");
        }
        /// <summary>
        /// 静态构造函数:由CLR保证，程序第一次使用这个类型前被调用，且只调用一次
        /// 
        /// 写日志功能的文件夹检测
        /// XML配置文件
        /// </summary>
        static SingletonSecond()
        {
            _SingletonSecond = new SingletonSecond();
            Console.WriteLine("SingletonSecond 被启动");
        }

8设计模 
 适配器模式..用在第三方接口 比如 第三方 增删查改功能...封装成自己类去 调用 做包多一层去调用 这个类放到其他地方也可以用同样功能
 责任链模式：用在业务流程使用  像物流柜项目  每个 送修 报修 报价 等 固定流程.. 
 观察者模式：等待订阅 用户行为 去利用多播委托去实现添加 如果有添加功能 直接添加 事件就O